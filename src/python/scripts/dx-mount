#!/usr/bin/env python

#TODO: if creating new file with existing name - unanle to write data into it

'''
All folders in root represent projects. If more then one project exist with same name,
then suffix ".<project_id>" will be added.
'''

from __future__ import print_function

import os, sys, re, uuid

# Try to reset encoding to utf-8
# Note: This is incompatible with pypy
# Note: In addition to PYTHONIOENCODING=UTF-8, this also enables command-line arguments to be decoded properly.
import platform, locale
sys_encoding = locale.getdefaultlocale()[1] or 'UTF-8'
if platform.python_implementation() != "PyPy":
    try:
        reload(sys).setdefaultencoding(sys_encoding)
    except:
        pass

import logging, stat, argparse, json, threading

from errno import ENOENT, ENOTDIR, EPERM, ENOSYS
from time import time

from fuse import FUSE, FuseOSError, Operations, LoggingMixIn

import dxpy
dxpy.USER_AGENT += " dxfs"

if not hasattr(__builtins__, 'bytes'):
    bytes = str


def _get_size(obj):
    if obj["class"] == "gtable":
        # HACK to get gtables to sort of work for now. TODO: Add enough bytes to account for all the tabs and newlines in the tsv output.
        return obj.get('size', 0) * 2
    else:
        return obj.get('size', 0)


class Project:

    def __init__(self, project=None, id=None, description=None, mtime=None):
        self.id = id
        self.project = project
        self.description = description
        self.mtime = mtime


class DXInode(object):
    DIR  = 'dir'
    FILE = 'file'
    LINK = 'link'

    def __init__(self, type, name, mode, uid, gid, ctime=None, mtime=None, size=0, dxid=None, describe=None):
        logger.debug("New inode {} {} {} {} {}".format(type, name.encode('utf-8'), mode, uid, gid))
        self.type = type
        self.name = name     # file name
        self.dev  = 0        # device ID (if special file)
        self.mode = mode     # protection and file-type
        self.uid  = uid      # user ID of owner
        self.gid  = gid      # group ID of owner
        self.size = size

        self.dxid = dxid
        self.describe = describe

        self.now()

        # Extended Attributes
        self.xattr = {}

        # Data
        if stat.S_ISDIR(mode):
            # {node name -> node}
            self.child_nodes = {}
        else:
            self.data = ''

        if ctime:
            self.ctime = ctime
        if mtime:
            self.mtime = mtime

        self._handler = None

    @property
    def handler(self):
        if self._handler is None and self.dxid is not None:
            self._handler = dxpy.get_handler(self.dxid, project=self.describe['project'])
        return self._handler

    @handler.setter
    def handler(self, h):
        self._handler = h

    def reload(self):
        self._handler = dxpy.get_handler(self.dxid)

    def now(self):
        self.atime = time()   # time of last access
        self.mtime = self.atime    # time of last modification
        self.ctime = self.atime    # time of last status change

    def stat(self):
        logger.debug("Constructing stat for {}".format(self.name.encode('utf-8')))
        try:
            stat = dict(
                st_mode  = self.mode,       # protection bits
                st_ino   = 0,               # inode number
                st_dev   = self.dev,        # device
                st_nlink = 2,               # number of hard links
                st_uid   = self.uid,        # user ID of owner
                st_gid   = self.gid,        # group ID of owner
                st_size  = self.size,       # size of file, in bytes
                st_atime = self.atime,      # time of most recent access
                st_mtime = self.mtime,      # time of most recent content modification
                st_ctime = self.ctime,      # platform dependent; time of most recent metadata change on Unix, or the time of creation on Windows
            )
        except Exception as e:
            logger.error("EXCEPTION {}".format(str(e)))
        logger.debug("returning stat for {}".format(self.name.encode('utf-8')))
        return stat

    def child(self, path):
        logger.debug('{name} asked for child {path}'.format(name=self.name.encode('utf-8'), path=path.encode('utf-8')))
        match = None
        if self.type == DXInode.DIR:
            nodes = path.split('/')
            if nodes[0] in self.child_nodes:
                child = self.child_nodes[nodes[0]]
                if len(nodes) > 1:
                    match = child.child('/'.join(nodes[1:]))
                else:
                    match = child
                    logger.debug("Found child {}".format(match.name.encode('utf-8')))
        return match

    def read(self, offset, length):
        logger.debug("Reading from {} {} {}".format(self.name.encode('utf-8'), offset, length))
        #stat.st_atime = time.now()
        if self.dxid and self.dxid.startswith('file'):
            if self.handler.state != 'closed':
                self.reload()
                if self.handler.state != 'closed':
                    return ''
            self.handler.seek(offset)
            return self.handler.read(length)
        elif self.dxid and self.dxid.startswith('gtable'):
            # TODO: make this less naive
            if self.handler.state != 'closed':
                self.reload()
            rows = ""
            for row in self.handler:
                rows += ("\t".join(map(unicode, row))+"\n").encode('utf-8')
                if len(rows) >= offset+length:
                    break
            return rows[offset:offset+length]
        elif self.dxid and self.dxid.startswith('record'):
            return json.dumps(self.handler.get_details(), encoding='utf-8')[offset:offset+length]
        else:
            return self.data[offset:offset+length]

    def write(self, offset, data):
        if self.dxid and self.dxid.startswith('file'):
            # TODO: write seek, overwrite, append?
            if self.handler.closed():
                logger.error('File closed! Writing not supported')
                #raise NotImplementedError('File closed! Writing not supported')
            else:
                self.handler.write(data)
                self.handler.close()
        else:
            raise NotImplementedError()

        # TODO: update size of self
        self.now()
        return len(data)

    def truncate(self, length):
        logger.debug("Truncating {}".format(self.name.encode('utf-8')))
        self.data = self.data[0:length]
        self.now()


class DXFS(LoggingMixIn, Operations):
    def __init__(self, project_id, mount_all, refresh_interval=5):
        self.fd = 0
        self.uid = os.getuid()
        self.gid = os.getgid()
        self.project_id = project_id
        self.mount_all = mount_all
        self.root = DXInode(DXInode.DIR, 'root', 0755 | stat.S_IFDIR, self.uid, self.gid)
        self.last_created = 0
        self.refresh_interval = refresh_interval
        self.initialized_once = threading.Event()
        self.projects = []


    def wait_until_initialized(self):
        # Run a less expensive check that doesn't need to acquire a
        # lock, so we can possibly short-circuit the real wait() call,
        # which does.
        if not self.initialized_once.is_set():
            self.initialized_once.wait()

    def init(self, root_path):
        ''' This method is used for fetching projects and initializing the filesystem
        '''

        # The event initialized_once is used to prevent any external
        # calls to filesystem methods from being processed until we have
        # populated the filesystem for the first time. This prevents the
        # user from seeing the filesystem in an empty state. All
        # filesystem methods (except trivial ones like statfs) should
        # call self.wait_until_initialized() before proceeding. As a
        # corollary, any filesystem method foo that is liable to be
        # called from init() should be factored out into a 'foo' method
        # for public consumption and a '_foo' method for internal use,
        # where only the 'foo' method calls wait_until_initialized, and
        # init() only calls the '_foo' (non-waiting) version.

        # Get list of project(s)
        if self.mount_all:
            all_projects = list(dxpy.find_projects(describe=True))
            for pr in all_projects:
                self.projects += [Project(project=dxpy.DXProject(pr['id']), id=pr['id'], description=pr['describe'])]
        elif self.project_id.startswith('project-'):
            self.projects += [Project(project=dxpy.DXProject(self.project_id), id=self.project_id)]
        elif self.project_id.startswith('container-'):
            self.projects += [Project(project=dxpy.DXContainer(self.project_id), id=self.project_id)]
        logger.debug('Received {} projects from API server'.format(len(self.projects)))

        # This is where the old tree gets blown away (when reloading).
        self.root = DXInode(DXInode.DIR, 'root', 0755 | stat.S_IFDIR, self.uid, self.gid)
        for project in self.projects:
            self._populate(project)

        logger.debug('Finished init')

        if not self.initialized_once.is_set():
            self.initialized_once.set()

        threading.Timer(self.refresh_interval, self.refresh).start()

    def _populate(self, project):
        ''' This method is used for initializing/reloading the filesystem it upon modification '''
        # Save old project name before description refresh. It can be useful if project was renamed via DX
        old_name = project.description['name'] if project.description else None
        project.description = project.project.describe(input_params={"folders": True})
        project.mtime = project.description['modified']
        folders = project.description['folders']
        folders.sort(key=lambda item: (len(item), item))
        logger.debug("Populating folders for project {} ...".format(project.description['id']))
        logger.debug("Found {num} folders in project {name}".format(num=len(folders),
                                                                    name=project.description['name'].encode('utf-8')))

        # Create root project directory, for similar names add ID as suffix
        if [x.description['name'] for x in self.projects].count(project.description['name']) > 1:
            prefix = '/' + project.description['name'] + '.' + project.id
        else:
            prefix = '/' + project.description['name']

        # Check if project was renamed via DX, then remove old root directory
        if old_name:
            if prefix not in ['/' + old_name, '/' + old_name + '.' + project.id]:
                parent = self._parent('/' + old_name)
                del parent.child_nodes[old_name]

        # Create new ROOT directory
        self._mkdir(prefix, 0755 | stat.S_IFDIR, make_remote=False)

        for path in folders:
            if path == '/':
                continue
            try:
                self._mkdir(prefix + path, 0755 | stat.S_IFDIR, make_remote=False)
                logger.debug('{} folder created'.format(prefix.encode('utf-8') + path.encode('utf-8')))
            except Exception as error:
                logger.error("Failed to create directory {path} for project {id}\nMessage: {mes}".format(
                    path=prefix.encode('utf-8') + path.encode('utf-8'), id=project.description['id'], mes=str(error)))
                continue

        logger.debug("Populated {} folders".format(len(folders) - 1))
        logger.debug("Populating data objects...")

        for i in dxpy.search.find_data_objects(project=project.id, describe=True):
            self._new_dataobject(i["describe"], prefix=prefix)

    def _new_dataobject(self, dataobject, add_missing_folders=False, prefix='/'):
        '''Now we allow only file and folder objects'''
        logger.debug('Creating new dataobject {}'.format(dataobject["name"].encode('utf-8')))
        if not dataobject['class'] in ['file', 'folder']:
            logger.debug('Object {} not file or folder, skipping'.format(dataobject["name"].encode('utf-8')))
            return

        dataobject["folder"] = str(dataobject["folder"])
        dataobject["name"] = str(dataobject["name"]).replace("/", "").replace("\0", "")

        if add_missing_folders:
            folderpath = ''
            for path_element in dataobject["folder"].split('/')[1:]:
                folderpath += path_element
                if not self.root.child(folderpath):
                    self._mkdir(str('/' + folderpath), 0755 | stat.S_IFDIR, make_remote=False)
                folderpath += '/'

        if dataobject["class"] == "applet" or (dataobject["class"] == "record" and "pipeline" in dataobject["types"]):
            mode = 0755
        else:
            mode = 0644

        path = os.path.join(prefix, dataobject["folder"].lstrip('/'), dataobject["name"])
        self._create(path,
                     mode,
                     ctime=dataobject['created']/1000,
                     mtime=dataobject['modified']/1000,
                     size=_get_size(dataobject),
                     dxid=dataobject['id'],
                     describe=dataobject)
        logger.debug('Object {name} created with size {size}'.format(name=dataobject['name'].encode('utf-8'), size=_get_size(dataobject)))
        self.last_created = max(self.last_created, dataobject['created'])

    def _get_project_from_path(self, path):
        """
        This method return Project object for path.
        If Path is ROOT folder (represent project itself), then return None
        """
        root_folder = path.split('/')[1]
        if not root_folder:
            raise IndexError
        #find it by ID in suffix then by name
        if root_folder.split('.')[-1] in [x.description['id'] for x in self.projects]:
            return next(x for x in self.projects if x.description['id'] == root_folder.split('.')[-1])
        elif root_folder in [x.description['name'] for x in self.projects]:
            return next(x for x in self.projects if x.description['name'] == root_folder)
        else:
            # None means no project found - path can be just created root directory and project not yet exist
            return None

    def _get_path_without_project_name(self, path):
        """
        This method return full path without prefix that represent Project name(with ID)
        """
        pattern = re.compile(ur'^/.*?((?=/)|(?=$))')
        return re.sub(pattern, '', path) or '/'

    def _get_unique_file_name(self, path, dxid):
        """This method checks if other file exist with same name, then add suffix as '.<id>'"""
        logger.debug('generating unique filename for {}'.format(path.encode('utf-8')))
        if dxid in os.path.basename(path).split('.'):
            original_name = os.path.basename(path).split('.')[0]
        else:
            original_name = os.path.basename(path)
        dx_path = self._get_path_without_project_name(path)
        project = self._get_project_from_path(path)
        folder = os.path.dirname(dx_path)
        objects = project.project.list_folder(folder=folder, describe={'fields': {'id': True, 'name': True, 'class': True}})
        files = [x['describe']['name'] for x in objects['objects'] if x['describe']['class'] == 'file']
        if files.count(original_name) > 1:
            return original_name + '.' + dxid
        else:
            return original_name

    def refresh(self):
        # Refresh project list in case if all mounted
        logger.debug('Refreshing filesystem')
        if self.mount_all:
            all_projects = list(dxpy.find_projects(describe=True))
            for pr in all_projects:
                if pr['id'] not in [x.id for x in self.projects]:
                    self.projects += [Project(project=dxpy.DXProject(pr['id']), id=pr['id'],
                                              description=pr['describe'], mtime=pr['describe']['modified'])]
                    self._populate(next(x for x in self.projects if x.id == pr['id']))
            # Remove projects which does not exist
            for project in self.projects:
                if project.id not in [x['id'] for x in all_projects]:
                    if [x.description['name'] for x in self.projects].count(project.description['name']) > 1:
                        prefix = os.path.join('/', project.description['name'] + '.' + project.id)
                    else:
                        prefix = os.path.join('/', project.description['name'])
                    logger.debug('Removing project {} from list as it doesn\'t exist'.format(project.id))
                    self._rmdir(prefix, remove_remote=False)
                    self.projects.remove(project)


        # Populate content for modified projects
        for project in self.projects:
            new_mtime = project.project.describe(input_params={"fields": {"modified": True}})['modified']

            if project.mtime < new_mtime:
                logger.debug("Project {id} was modified ({t1} < {t2}), reloading".format(id=project.description['id'],
                                                                                  t1=project.mtime, t2=new_mtime))
                self._populate(project)

        threading.Timer(self.refresh_interval, self.refresh).start()

    def chmod(self, path, mode):
        self.wait_until_initialized()
        logger.info('CHMOD mode:{mode} path:{path}'.format(mode=mode, path=path.encode('utf-8')))
        node = self._node(path)
        if not node:
            raise FuseOSError(ENOENT)
        node.mode = mode
        return 0

    def chown(self, path, uid, gid):
        self.wait_until_initialized()
        logger.info('CHOWN {uid}:{gid} path:{path}'.format(path=path.encode('utf-8'), uid=uid, gid=gid))
        node = self._node(path)
        if not node:
            raise FuseOSError(ENOENT)
        node.uid = uid
        node.gid = gid

    def create(self, *args, **kwargs):
        self.wait_until_initialized()
        return self._create(*args, **kwargs)

    def _create(self, path, mode, ctime=None, mtime=None, size=0, dxid=None, describe=None):
        logger.info('CREATE path:{path} mode:{mode}'.format(mode=mode, path=path.encode('utf-8')))

        if self._get_path_without_project_name(path) == '/':
            logger.error('Creating objects of non-folder type in the root directory isn\'t permitted')
            raise FuseOSError(EPERM)

        if ctime is None:
            ctime = time()
        if mtime is None:
            mtime = time()

        dirname, filename = os.path.split(path)
        parent = self._parent(path)

        if not parent:
            raise FuseOSError(ENOENT)

        if not parent.type == DXInode.DIR:
            raise FuseOSError(ENOTDIR)

        project = self._get_project_from_path(path)

        if dxid is None:
            files = list((v.describe['name'] for k, v in parent.child_nodes.iteritems() if v.type == 'file'))
            if os.path.basename(path) in files:
                logger.error('Creating file with non-unique name is not allowed!')
                raise FuseOSError(EPERM)

            f = dxpy.new_dxfile(name=filename, project=project.description['id'],
                                folder=self._get_path_without_project_name(dirname))
            dxid = f.get_id()
            describe = f.describe()
        unique_name = self._get_unique_file_name(path, dxid)
        node = DXInode(DXInode.FILE, unique_name, mode | stat.S_IFREG, self.uid, self.gid,
                       ctime=ctime, mtime=mtime, size=size, dxid=dxid, describe=describe)
        logger.debug("Adding file {file} to {target}".format(file=node.name.encode('utf-8'),
                                                             target=parent.name.encode('utf-8')))
        parent.child_nodes[node.name] = node
        #debug("Parent contents:", parent.data)

        # self.files[path] = dict(st_mode=(S_IFREG | mode), st_nlink=1,
        #                         st_size=0, st_ctime=time(), st_mtime=time(),
        #                         st_atime=time())

        self.fd += 1
        return self.fd

    def getattr(self, path, fh=None):
        self.wait_until_initialized()
        logger.debug('GETATTR path:{}'.format(path.encode('utf-8')))
        node = self._node(path)
        if not node:
            logger.debug("getattr: {} not found".format(path.encode('utf-8')))
            raise FuseOSError(ENOENT)
        else:
            return node.stat()

    def getxattr(self, path, name, position=0):
        self.wait_until_initialized()
        logger.debug('GETXATTR path:{path} name:{name}'.format(path=path.encode('utf-8'), name=name.encode('utf-8')))

        node = self._node(path)
        if not node:
            raise FuseOSError(ENOENT)
        elif node.describe is None or node.handler is None:
            raise FuseOSError(ENOENT)

        # The following attributes are "mutable" and need to be fetched
        # anew each time. This whitelist is most useful for allowing
        # fast (no API call needed) access to random properties like
        # "security.selinux" that clients will query for but will never
        # exist in the describe output.
        if name in ('state', 'name', 'folder', 'sponsored', 'tags', 'modified'):
            describe = node.handler.describe()
        else:
            describe = node.describe

        # See also ENOATTR
        value = str(describe.get(name, ''))

        return value

    def listxattr(self, path):
        self.wait_until_initialized()
        logger.info('LISTXATTR path:{}'.format(path.encode('utf-8')))

        node = self._node(path)
        if not node:
            raise FuseOSError(ENOENT)

        attrs = [str(attr) for attr in node.describe.keys()]
        logger.debug(attrs)
        return attrs

    def mkdir(self, *args, **kwargs):
        self.wait_until_initialized()
        return self._mkdir(*args, **kwargs)

    def _mkdir(self, path, mode, make_remote=True):
        logger.info('MKDIR path:{path} mode:{mode}'.format(path=path.encode('utf-8'), mode=mode))

        dirname, filename = os.path.split(path)
        parent = self._parent(path)

        if not parent:
            raise FuseOSError(ENOENT)

        if not parent.type == DXInode.DIR:
            raise FuseOSError(ENOTDIR)

        if make_remote:
            if dirname == '/':
                dxpy.DXProject(None).new(name=filename)
                logger.info('Directory in root folder, new project created with name {}'.format(filename.encode('utf-8')))
            else:
                project = self._get_project_from_path(path)
                project.project.new_folder(self._get_path_without_project_name(path))
                logger.debug('New directory created on server: {}'.format(self._get_path_without_project_name(path.encode('utf-8'))))

        node = DXInode(DXInode.DIR, filename, mode | stat.S_IFDIR, self.uid, self.gid)
        logger.debug("Adding dir {name} to {parent}".format(name=node.name.encode('utf-8'), parent=parent.name.encode('utf-8')))
        parent.child_nodes[node.name] = node
        logger.debug("Parent contents: {}".format(parent.child_nodes))

    # def open(self, path, flags):
    #     self.fd += 1
    #     return self.fd

    def read(self, path, size, offset, fh):
        self.wait_until_initialized()
        logger.info('READ path:{} size:{} offset:{}'.format(path.encode('utf-8'), size, offset))

        node = self._node(path)

        if not node:
            raise FuseOSError(ENOENT)

        return node.read(offset, size)

    def readdir(self, path, fh):
        self.wait_until_initialized()
        logger.debug('READDIR path:{}'.format(path.encode('utf-8')))

        node = self._node(path)

        for meta in ['.', '..']:
            logger.debug("yielding {}".format(meta))
            yield meta
            #yield fuse.Direntry(meta)
        for child_name in node.child_nodes:
            logger.debug("yielding {}".format(child_name.encode('utf-8')))
            yield child_name
            #yield fuse.Direntry(child.name)

    def readlink(self, path):
        self.wait_until_initialized()
        logger.debug('READLINK path:{}'.format(path.encode('utf-8')))

        node = self._node(path)
        if not node:
            raise FuseOSError(ENOENT)

        return node.data

    def removexattr(self, path, name):
        self.wait_until_initialized()
        logger.info('REMOVEXATTR path:{path} name:{name}'.format(path=path.encode('utf-8'), name=name.encode('utf-8')))

        node = self._node(path)
        if not node:
            raise FuseOSError(ENOENT)

        if name in node.xattr:
            del node.xattr[name]
        # See also ENOATTR

    def rename(self, oldpath, newpath):
        self.wait_until_initialized()
        logger.info('RENAME executed, old name:{old} new name:{new}'.format(old=oldpath.encode('utf-8'), new=newpath.encode('utf-8')))

        old_dirname, old_filename = os.path.split(oldpath)
        new_dirname, new_filename = os.path.split(newpath)
        old_parent = self._parent(oldpath)
        new_parent = self._parent(newpath)
        node       = self._node(oldpath) 

        if not (old_parent or new_parent or node):
            raise FuseOSError(ENOENT)

        if not new_parent.type == DXInode.DIR:
            raise FuseOSError(ENOTDIR)

        # Check filename for duplicates and rename destination if needed. Original name we taking from node
        if node.type == DXInode.FILE:
            new_filename = self._get_unique_file_name(newpath, node.handler.get_id())

        node.name = new_filename
        project_new = self._get_project_from_path(newpath)
        project_old = self._get_project_from_path(oldpath)
        if node.type == DXInode.DIR:
            if project_new == project_old and project_new:
                dxpy.api.project_rename_folder(project_new.id, {"folder": self._get_path_without_project_name(oldpath),
                                                            "newpath": self._get_path_without_project_name(newpath)})
            elif old_dirname == new_dirname == '/' and project_old and not project_new:
                pr = self._get_project_from_path(oldpath)
                pr.project.update(name=new_filename)
            else:
                logger.error('Moving objects in this way not implemented!')
                raise FuseOSError(ENOSYS)

        else:
            if new_dirname != old_dirname:
                project_new.project.move(self._get_path_without_project_name(new_dirname), [node.handler.get_id()])
            node.handler.rename(new_filename)

        del old_parent.child_nodes[old_filename]
        new_parent.child_nodes[new_filename] = node

    def rmdir(self, path):
        self.wait_until_initialized()
        return self._rmdir(path)

    def _rmdir(self, path, remove_remote=True):
        logger.info('RMDIR path:{}'.format(path.encode('utf-8')))

        parent = self._parent(path)
        node = self._node(path)

        if not (parent or node):
            raise FuseOSError(ENOENT)

        if not node.type == DXInode.DIR:
            raise FuseOSError(ENOTDIR)

        if remove_remote:
            project = self._get_project_from_path(path)
            directory = self._get_path_without_project_name(path)
            if directory == '/':
                project.project.destroy()
                self.projects.remove(project)
                logger.info('Directory in root folder. Project {} removed'.format(project.id))
            else:
                project.project.remove_folder(directory)
        del parent.child_nodes[node.name]

    def setxattr(self, path, name, value, flags, position=0):
        self.wait_until_initialized()
        logger.info('SETXATTR path:{path} name:{name} value:{value}'.format(
                    path=path.encode('utf-8'), name=name.encode('utf-8'), value=value))

        node = self._node(path)
        if not node:
            raise FuseOSError(ENOENT)

        if name == 'tag':
            node.handler.add_tags([value])
        elif name == 'property':
            prop_name, prop_value = value.split(":")
            node.handler.add_properties({prop_name: prop_value})
        elif name == 'state' and value == 'closed':
            logger.debug("closing {}".format(node))
            node.handler.close(block=True)
            node.reload()
            node.size = node.handler.size
            logger.debug("closed {}".format(node))
        node.xattr[name] = value

    def statfs(self, path):
        return dict(f_bsize=512, f_blocks=4096, f_bavail=2048)

    def symlink(self, target, source):
        self.wait_until_initialized()
        logger.info('SYMLINK target:{target} source:{source}'.format(target=target.encode('utf-8'),
                                                                     source=source.encode('utf-8')))

        source_node = self._node(target)
        filename    = os.path.basename(source)
        parent      = self._parent(source)

        if not (parent or source_node):
            raise FuseOSError(ENOENT)

        if not parent.type == DXInode.DIR:
            raise FuseOSError(ENOTDIR)

        node = DXInode(DXInode.LINK, filename, 0644 | stat.S_IFLNK, self.uid, self.gid)
        node.data = target

        parent.child_nodes[node.name] = node

    def truncate(self, path, length, fh=None):
        self.wait_until_initialized()
        logger.info('TRUNCATE path:{path}, length:{length}'.format(path=path.encode('utf-8'), length=length))

        node = self._node(path)

        if not node:
            raise FuseOSError(ENOENT)

        node.truncate(length)

    def unlink(self, path):
        self.wait_until_initialized()
        logger.info('UNLINK path:{}'.format(path.encode('utf-8')))

        parent = self._parent(path)
        child  = self._node(path)

        if not (parent or child):
            raise FuseOSError(ENOENT)

        logger.debug("Removing {}".format(child.handler))
        child.handler.remove()
        del parent.child_nodes[child.name]

    def utimens(self, path, times=None):
        self.wait_until_initialized()
        logger.info('UTIME executed, path:{} {}'.format(path.encode('utf-8'), times))

        node = self._node(path)
        if not node:
            raise FuseOSError(ENOENT)
        node.ctime = node.mtime = times[0]

    def write(self, path, data, offset, fh):
        """This method write data into file. In case file just created and handler still not closed,
            then we write data directly into file. Otherwise new temporary file will be created,
            old file removed and temp file renamed into original name
        """

        self.wait_until_initialized()
        logger.info('WRITE path:{path}, len:{data}, offset:{offset}'.format(path=path.encode('utf-8'), data=len(data),
                                                                            offset=offset))

        node = self._node(path)

        if not node:
            raise FuseOSError(ENOENT)

        if node.dxid in os.path.basename(path).split('.'):
            logger.error('Writing into file with not unique name is not allowed!')
            raise FuseOSError(EPERM)

        if not node.handler.closed():
            return node.write(offset, data)
        else:
            temp_filename = str(uuid.uuid4())
            temp_path = os.path.join(os.path.dirname(path), temp_filename)
            self._create(path=temp_path, mode=0644)
            temp_node = self._node(temp_path)
            data_len = temp_node.write(offset, data)
            self.unlink(path)
            self.rename(temp_path, path)
            return data_len

    # --- Tree Helpers
    def _node(self, path):
        if path == '/':
            return self.root
        else:
            return self.root.child(path[1:])

    def _parent(self, path):
        parent_path = os.path.dirname(path)
        return self._node(parent_path)

parser = argparse.ArgumentParser(description="DNAnexus FUSE driver")
parser.add_argument("mountpoint", help="Directory to mount the filesystem on")
group = parser.add_mutually_exclusive_group()
group.add_argument("--project-id", help="DNAnexus project ID to mount", default=dxpy.WORKSPACE_ID or '', nargs='?')
group.add_argument("--all", help="Mount root with all projects as subfolder", action='store_true')
parser.add_argument("--debug", action='store_true')
parser.add_argument("--foreground", action='store_true')
parser.add_argument("--logfile", help="Output log into file", metavar='<filename>')
parser.add_argument("--loglevel", help="Log level", choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'])
args = parser.parse_args()

if not args.project_id.startswith('project-') and not args.project_id.startswith('container-') and not args.all:
    parser.exit(3, "Error: A valid project or container ID was not provided for --project-id\n")

#format='%(asctime)s %(name)-1s %(levelname)-8s {user} %(message)s'.format(user=dxpy.whoami())
formatter = logging.Formatter('%(asctime)s %(levelname)-8s {user} %(message)s'.format(user=dxpy.whoami()), datefmt='%Y-%m-%d %H:%M:%S')
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
to_console = logging.StreamHandler(sys.stdout)
to_console.setLevel(logging.DEBUG if args.debug else logging.NOTSET)
to_console.setFormatter(formatter)
logger.addHandler(to_console)
if args.logfile:
    to_file = logging.FileHandler(args.logfile)
    to_file.setLevel(logging.getLevelName(args.loglevel) if args.loglevel else logging.INFO)
    to_file.setFormatter(formatter)
    logger.addHandler(to_file)

fuse = FUSE(DXFS(project_id=args.project_id, mount_all=args.all),
            args.mountpoint,
            foreground=args.foreground,
            nothreads=True,
            fsname='dnanexus:'+args.project_id,
            subtype='dxfs')

